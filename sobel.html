<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Sobel Edge Detection</title>
</head>
<body>
	<video id="webcam" autoplay style="display: none"></video>
	<canvas id="camfeed"></canvas>
	<canvas id="sobel"></canvas>
	<canvas id="zoomwindow"></canvas>

	<br />
	<button id="startBtn" onClick="computeFrame();">Start Edge Detection</button>
	<button id="stopBtn">Stop Edge Detection</button>


	<script type="text/javascript">

	var animating = false;


	var sobelKernelX = [
		[1,2,1],
		[0,0,0],
		[-1,-2,-1]
	];
	var sobelKernelY = [
		[1,0,-1],
		[2,0,-2],
		[1,0,-1]
	];


	/*
	 * This function is necessary since javascript stores 2-dimensional image data
	 * in 1-dimensional arrays
	 */
	function getIndex(x, y, width) {
	 	return (width * y) + x;
	}

	/*
	 * Returns a greyscaled version of an image
	 */
	function greyScale(image) {
	 	var data = new Uint8ClampedArray(image.data.length);
	 	for (var i = 0; i < image.data.length; i+=4) {
	 		var avg = image.data[i] + image.data[i+1] + image.data[i+2];
	 		avg = avg / 3;

	 		data[i] = data[i+1] = data[i+2] = avg;
			// Set opacity to max. Remember, this is RGBA, not RGB
			data[i+3] = 255;
		}

		return new ImageData(data, image.width, image.height);
	}

	/*
	 * Convolves image with 2 kernels to get edge gradients in the x and y direction
	 * and combines those values to get a general "edge" intensity
	 */
	function dualConvolve(image, kernelx, kernely, kernelHeight, kernelWidth) {
	 	var output = new ImageData(image.width, image.height);

	 	// The offsets are used in calculating the similar pixel in the kernel and the image portion
	 	// currently being convolved
	 	var offsetX = Math.floor(kernelWidth / 2);
	 	var offsetY = Math.floor(kernelHeight / 2);

		// Inner region 1 pixel in from boundaries because edge cases are tricky
		for (var x = 1; x < image.width - 1; x++) {
			for (var y = 1; y < image.height - 1; y++) {
				var xAccumulator = 0;
				var yAccumulator = 0;

				for (var kx = 0; kx < kernelWidth; kx++) {
					for (var ky = 0; ky < kernelHeight; ky++) {
						xAccumulator += kernelx[kx][ky] * image.data[getIndex(x + offsetX - kx, y + offsetY - ky, image.width) * 4];
						yAccumulator += kernely[kx][ky] * image.data[getIndex(x + offsetX - kx, y + offsetY - ky, image.width) * 4];
					}
				}

				var finalEdgeValue = Math.sqrt((xAccumulator * xAccumulator) + (yAccumulator * yAccumulator));

				var index = getIndex(x,y,image.width) * 4;
				output.data[index] = output.data[index + 1] = output.data[index + 2] = finalEdgeValue;
				output.data[index + 3] = 255;
			}
		}
		return output;
	}

	function computeFrame() {
		var videoElement = document.getElementById('webcam');
		var camfeedctx = document.getElementById('camfeed').getContext('2d');
		camfeedctx.drawImage(
			videoElement,
			0,
			0,
			videoElement.videoWidth * 0.75,
			videoElement.videoHeight * 0.75
		);

		var inputImage = camfeedctx.getImageData(0,0,videoElement.videoWidth * 0.75, videoElement.videoHeight * 0.75);

		inputImage = greyScale(inputImage);
		outputImage = dualConvolve(inputImage, sobelKernelX, sobelKernelY, 3, 3);

		document.getElementById('sobel').getContext('2d').putImageData(outputImage, 0, 0);

		if (!document.getElementById('stopBtn').clicked) {
			requestAnimationFrame(computeFrame);
		}
	}


	function initCamera() {
		navigator.mediaDevices.getUserMedia({video: true}).then(
			function(stream) {
				document.getElementById('webcam').srcObject = stream;
				document.getElementById('webcam').addEventListener('playing', function(event) {
					document.getElementById('camfeed').width = document.getElementById('webcam').videoWidth;
					document.getElementById('camfeed').height = document.getElementById('webcam').videoHeight;

					document.getElementById('sobel').width = document.getElementById('webcam').videoWidth;
					document.getElementById('sobel').height = document.getElementById('webcam').videoHeight;
				})
			}
		).catch(
			function(err) {
				alert(err);
			}
		);
	}

	initCamera();
	</script>
	</html>