<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Sobel Edge Detection</title>
</head>
<body>
	<h1>Sobel Edge Detection</h1>
	<table>
		<tr>
			<td>1</td>
			<td>2</td>
			<td>1</td>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>-1</td>
			<td>-2</td>
			<td>-1</td>
		</tr>
	</table>
	<p>
		The Sobel operator is a kernel used for edge detection. The kernel can, however, only detect a gradient in intensity along one direction,
		so with this kernel, a perfectly vertical edge would not register, and as an edge moves from being horizontal to vertical, it becomes
		less intense in the output of the convolution. Below you can see the result of convolving an image with this matrix, then with the same
		matrix rotated 90 degrees, and then with a combined value for the two. Try taking an object with a straight edge and rotate it. See how the 
		edge changes in intensity in the first two images as it is being rotated, but changes little in the image that combines the two. 
	</p>
		<video id="webcam" autoplay style="display: none"></video>
	
	<canvas id="camfeed"></canvas>
	<canvas id="sobelx"></canvas>
	<canvas id="sobely"></canvas>
	<canvas id="sobelboth"></canvas>

	<canvas id="zoomwindow"></canvas>

	<br />
	<button id="startBtn" onClick="animating = true;computeFrame();">Start Edge Detection</button>
	<button id="stopBtn">Stop Edge Detection</button>


	<script type="text/javascript">

	var animating = false;

	var sobelKernel = [[1,0,-1],[2,0,-2],[1,0,-1]];
	var sobelRotated = [[1,2,1],[0,0,0],[-1,-2,-1]];


	/*
	 * This function is necessary since javascript stores 2-dimensional image data
	 * in 1-dimensional arrays
	 */
	function getIndex(x, y, width, height) {
	 	
		// The following 4 if statements are used to "extend" the image beyond it's boundaries so that edge and corner
		// pixels can be calculated as well.
	 	if (x < 0) {
	 		x++;
	 	}
	 	if (y < 0) {
	 		y++;
	 	}
	 	if (x >= width) {
	 		x = width - 1;
	 	}
	 	if (y >= height) {
	 		y = height - 1;
	 	}
	 	return (width * y) + x;
	}

	/*
	 * Returns the result of performing a gaussian blur on an image
	 */
	function gaussianBlur(image) {
		var kernel = [1/256,4/256,6/256,4/256,1/256];
		var offset = 2;
		var data = new Uint8ClampedArray(image.width * image.height * 4);

		for (var x = 0; x < image.width; x++) {
			for (var y = 0; y < image.width; y++) {
				var r = 0;
				var g = 0;
				var b = 0;

				for (var i = 0; i < 5; i ++) {
					r += kernel[i] * image.data[getIndex(x + offset - i, y, image.width, image.height) * 4];
					g += kernel[i] * image.data[(getIndex(x + offset - i, y, image.width, image.height) * 4) + 1];
					b += kernel[i] * image.data[(getIndex(x + offset - i, y, image.width, image.height) * 4) + 2];
				}
				
				var index = getIndex(x,y,image.width, image.height) * 4;
				data[index] = r;
				data[index + 1] = g;
				data[index + 2] = b;
				data[index + 3] = 255;
			}
		}

		var output = new ImageData(image.width, image.height);
		for (var x = 0; x < image.width; x++) {
			for (var y = 0; y < image.width; y++) {
				var r = 0;
				var g = 0;
				var b = 0;

				for (var i = 0; i < 5; i ++) {
					r += kernel[i] * data[getIndex(x, y + offset - i, image.width, image.height) * 4];
					g += kernel[i] * data[(getIndex(x, y + offset - i, image.width, image.height) * 4) + 1];
					b += kernel[i] * data[(getIndex(x, y + offset - i, image.width, image.height) * 4) + 2];
				}
				
				var index = getIndex(x,y,image.width, image.height) * 4;
				output.data[index] = r;
				output.data[index + 1] = g;
				output.data[index + 2] = b;
				output.data[index + 3] = 255;
			}
		}
		return output;
	}

	/*
	 * Returns a greyscaled version of an image
	 */
	function greyScale(image) {
	 	var data = new Uint8ClampedArray(image.data.length);
	 	for (var i = 0; i < image.data.length; i+=4) {
	 		var avg = image.data[i] + image.data[i+1] + image.data[i+2];
	 		avg = avg / 3;

	 		data[i] = data[i+1] = data[i+2] = avg;
			// Set opacity to max. Remember, this is RGBA, not RGB
			data[i+3] = 255;
		}

		return new ImageData(data, image.width, image.height);
	}


	function singleConvolve(image, kernel, kernelWidth, kernelHeight) {
		var output = new ImageData(image.width, image.height);

		var offsetX = Math.floor(kernelWidth / 2);
		var offsetY = Math.floor(kernelHeight / 2);

		for (var x = 0; x < image.width; x++) {
			for (var y = 0; y < image.height; y ++) {
				var accumulator = 0;

				for (var kx = 0; kx < kernelWidth; kx++) {
					for (var ky = 0; ky < kernelHeight; ky++) {
						accumulator += kernel[kx][ky] * image.data[getIndex(x + offsetX - kx, y + offsetY - ky, image.width, image.height) * 4];
					}
				}

				var index = getIndex(x,y,image.width,image.height) * 4;
				output.data[index] = output.data[index + 1] = output.data[index + 2] = Math.abs(accumulator);
				output.data[index + 3] = 255;
			}
		}

		return output;
	}

	function combineConvolutions(image1, image2) {
		var output = new ImageData(image1.width, image1.height);

		for (var i = 0; i < image1.data.length; i+=4) {
			var val1 = image1.data[i];
			var val2 = image2.data[i];

			output.data[i] = output.data[i + 1] = output.data[i + 2] = Math.sqrt((val1 * val1) + (val2 * val2));
			output.data[i + 3] = 255;
		}

		return output;
	}

	function computeFrame() {
		var videoElement = document.getElementById('webcam');
		var camfeedctx = document.getElementById('camfeed').getContext('2d');
		camfeedctx.drawImage(
			videoElement,
			0,
			0,
			videoElement.videoWidth * 0.75,
			videoElement.videoHeight * 0.75
		);

		var inputImage = camfeedctx.getImageData(0,0,videoElement.videoWidth * 0.75, videoElement.videoHeight * 0.75);

		inputImage = greyScale(inputImage);
		var x = singleConvolve(inputImage, sobelKernel, 3, 3);
		var y = singleConvolve(inputImage, sobelRotated, 3, 3);
		var both = combineConvolutions(x,y);

		document.getElementById('sobelx').getContext('2d').putImageData(x, 0, 0);
		document.getElementById('sobely').getContext('2d').putImageData(y, 0, 0);
		document.getElementById('sobelboth').getContext('2d').putImageData(both, 0, 0);

		if (animating) {
			requestAnimationFrame(computeFrame);
		}
	}


	function initCamera() {
		navigator.mediaDevices.getUserMedia({video: true}).then(
			function(stream) {
				document.getElementById('webcam').srcObject = stream;
				document.getElementById('webcam').addEventListener('playing', function(event) {
					document.getElementById('camfeed').width = document.getElementById('webcam').videoWidth * 0.75;
					document.getElementById('camfeed').height = document.getElementById('webcam').videoHeight * 0.75;

					document.getElementById('sobelx').width = document.getElementById('webcam').videoWidth * 0.75;
					document.getElementById('sobelx').height = document.getElementById('webcam').videoHeight * 0.75;

					document.getElementById('sobely').width = document.getElementById('webcam').videoWidth * 0.75;
					document.getElementById('sobely').height = document.getElementById('webcam').videoHeight * 0.75;

					document.getElementById('sobelboth').width = document.getElementById('webcam').videoWidth * 0.75;
					document.getElementById('sobelboth').height = document.getElementById('webcam').videoHeight * 0.75;
				})
			}
		).catch(
			function(err) {
				alert(err);
			}
		);
	}

	document.getElementById('stopBtn').addEventListener('click', function (event) {
		animating = false;
	})
	initCamera();
	</script>
</html>