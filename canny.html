<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Canny Edge Detection</title>
</head>
<body>
	<script src="global.js"></script>	
	<h1>Canny Edge Detection</h1>
	
	<button id="startBtn" onClick="animating = true;computeFrame();">Start Edge Detection</button>
	<button id="stopBtn">Stop Edge Detection</button>
	<input type="checkbox" id="gaussianToggle" />Gaussian Blur
	<br />
	<input type="range" id="lowerThreshold" min="0" value="10" max="255" step="1" />
	<input type="range" id="upperThreshold" min="0" value="200" max="255" step="1" />

	<br />

	<canvas id="camfeed"></canvas>
	<canvas id="cannyoutput"></canvas>

	<canvas id="zoomwindow"></canvas>
	

	<video id="webcam" autoplay style="display: none"></video>
	<script type="text/javascript">

	const WEAK_EDGE = 1;
	const STRONG_EDGE = 2;

	var blur = false;
	var animating = false;


	const sobelKernel = [
		[1,0,-1],
		[2,0,-2],
		[1,0,-1]
	];
	const sobelRotated = [
		[1,2,1],
		[0,0,0],
		[-1,-2,-1]
	];

	function computeEdgeAngles(image1, image2) {
		var output = new Array(image1.width * image1.height);
		for (var i = 0; i < image1.data.length; i += 4) {
			var angle = Math.atan2(image1.data[i], image2.data[i]) * 180 / Math.PI;
			if (angle < 180) {
				if (angle < 90) {
					if (angle < 45) {
						if (angle < 22.5) {
							angle = 0;
						} else {
							angle = 45;
						}
					} else {
						if (angle < 67.5) {
							angle = 45;
						} else {
							angle = 90;
						}
					}
				} else {
					if (angle < 135) {
						if (angle < 112.5) {
							angle = 90;
						} else {
							angle = 135;
						}
					} else {
						if (angle < 157.5) {
							angle = 135;
						} else {
							angle = 0;
						}
					}
				}
			} else {
				if (angle < 270) {
					if (angle < 225) {
						if (angle < 202.5) {
							angle = 0;
						} else {
							angle = 45;
						}
					} else {
						if (angle < 247.5) {
							angle = 45;
						} else {
							angle = 90;
						}
					}
				} else {
					if (angle < 315) {
						if (angle < 292.5) {
							angle = 90;
						} else {
							angle = 135;
						}
					} else {
						if (angle < 337.5) {
							angle = 135;
						} else {
							angle = 0;
						}
					}
				}
			}
			output[i/4] = angle;
		}

		return output;
	}

	function edgeThinning(image, gradients) {
		var result = new ImageData(image.width, image.height);
		for (var x = 0; x < image.width; x++) {
			for (var y = 0; y < image.width; y++) {
				var index = getIndex(x,y,image.width,image.height) * 4;

				switch(gradients[index /4]) {
					case 0:
					if (image.data[index] === Math.max(image.data[index], image.data[getIndex(x, y + 1, image.width, image.height) * 4], image.data[getIndex(x, y - 1, image.width, image.height) * 4])) {
						result[index] = result[index + 1] = result[index + 2] = image.data[index];
					} else {
						result[index] = 0;
					}
					break;
					case 45:
					if (image.data[index] === Math.max(image.data[index], image.data[getIndex(x - 1, y + 1, image.width, image.height) * 4], image.data[getIndex(x + 1, y - 1, image.width, image.height) * 4])) {
						result[index] = result[index + 1] = result[index + 2] = image.data[index];
					} else {
						result[index] = 0;
					}
					break;
					case 90:
					if (image.data[index] === Math.max(image.data[index], image.data[getIndex(x - 1, y, image.width, image.height) * 4], image.data[getIndex(x + 1, y, image.width, image.height) * 4])) {
						result[index] = result[index + 1] = result[index + 2] = image.data[index];
					} else {
						result[index] = 0;
					}
					break;
					default:
					if (image.data[index] === Math.max(image.data[index], image.data[getIndex(x - 1, y - 1, image.width, image.height) * 4], image.data[getIndex(x + 1, y + 1, image.width, image.height) * 4])) {
						result[index] = result[index + 1] = result[index + 2] = image.data[index];
					} else {
						result[index] = 0;
					}
				}
				result.data[index + 3] = 255;
			}
		}
		return result;
	}

	function thresholding(image, upperThreshold, lowerThreshold) {
		var strengths = {
			data: new Array(image.width, image.height),
			width: image.width,
			height: image.height
		};
		for (var x = 0; x <image.width; x++) {
			for (var y = 0; y < image.height; y++) {

				var index = getIndex(x,y,image.width, image.height) * 4;
				if (image.data[index] > upperThreshold) {
					strengths.data[index/4] = STRONG_EDGE;
				} else if (image.data[index] > lowerThreshold) {
					strengths.data[index / 4] = WEAK_EDGE;
				} else {
					strengths[index / 4] = 0;
				}
			}
		}
		return strengths;
	}

	function edgeTracking(strengths) {
		var output = new ImageData(strengths.width, strengths.height);

		for (var x = 0; x < strengths.width; x++) {
			for (var y = 0; y < strengths.height; y++) {

				var index = getIndex(x,y,strengths.width, strengths.height);
				var imageIndex = index * 4

				if (strengths.data[index] === STRONG_EDGE) {
					output.data[imageIndex] = output.data[imageIndex + 1] = output.data[imageIndex + 2] = 255;
				} else if (strengths.data[index] === WEAK_EDGE) {
					// blob analysis
					var isEdge = false;
					for (var blobx = x - 1; blobx <= x + 1; blobx ++) {
						for (var bloby = y - 1; bloby <= y + 1; bloby++) {
							if (strengths.data[getIndex(blobx, bloby, strengths.width, strengths.height)] === STRONG_EDGE) {
								isEdge = true;
								break;
							}
						}
						if (isEdge) {
							break;
						}
					}
					output.data[imageIndex] = output.data[imageIndex + 1] = output.data[imageIndex + 2] = isEdge ? 255: 0;
				} else {
					output.data[imageIndex] = output.data[imageIndex + 1] = output.data[imageIndex + 2] = 0;
				}
				output.data[imageIndex + 3] = 255;
			}
		}
		return output;
	}

	function computeFrame() {
		var videoElement = document.getElementById('webcam');
		var camfeedctx = document.getElementById('camfeed').getContext('2d');
		camfeedctx.drawImage(
			videoElement,
			0,
			0,
			videoElement.videoWidth * 0.75,
			videoElement.videoHeight * 0.75
		);

		var inputImage = camfeedctx.getImageData(0,0,videoElement.videoWidth * 0.75, videoElement.videoHeight * 0.75);
		var greyScaled = greyScale(inputImage);
		var blurred = convolve(greyScaled, gaussKernel, 5, 5);
		var gx = convolve(blurred, sobelKernel, 3, 3);
		var gy = convolve(blurred, sobelRotated, 3, 3);

		var intensity = combineConvolutions(gx, gy);
		var directions = computeEdgeAngles(gy, gx);

		var thinnedEdges = edgeThinning(intensity, directions);
		//var thresholded = thresholding(thinnedEdges, document.getElementById('upperThreshold').value, document.getElementById('lowerThreshold').value);

		//var output = edgeTracking(thresholded);


		document.getElementById('cannyoutput').getContext('2d').putImageData(thinnedEdges, 0, 0);

		// if (animating) {
		// 	requestAnimationFrame(computeFrame);
		// }
	}


	document.getElementById('stopBtn').addEventListener('click', function (event) {
		animating = false;
	});

	document.getElementById('gaussianToggle').addEventListener('change', function(event) {
		if (this.checked) {
			blur = true;
		} else {
			blur = false;
		}
	});
	initCamera();
	</script>
</html>